// Read the `figure` element's responsive images and breakpoints for later reuse
// - the data gathered is passed to a callback function
var responsiveImageURL = function(elementID, callback) {
  var element = document.querySelector(elementID);
  var picture = element.querySelector('.picture');

  // Collect images and breakpoints from `picture`
  // - <source media="(min-width: 600px)" srcset="/assets/images/placeholder-16-9_tablet.png, /assets/images/placeholder-16-9_tablet2x.png 2x">
  // - start with mobile then go to desktop; media queries stop at the first match
  for (var i = picture.children.length - 1; i >= 0 ; i--) {
    var srcset = picture.children[i].srcset;
    var media = picture.children[i].media;
    var images = srcset.split(', ');

    for (var j = 0; j < images.length; j++) {
      var x2 = images[j].split(' 2x');
      var retina = (x2.length > 1);

      callback(element, x2[0], media, retina);
    }
  }
};

// Read the `figure` element's responsive images and breakpoints
// Set as background image with `matchMedia` coming from `Picturefill`
var setBackgroundImage = function(elementID) {

  // Set a responsive background image using `mathcMedia`
  function setResponsiveBackgroundImage(element, image, breakpoint, retina) {
    var mediaQuery = "only screen and " + breakpoint;

    if (retina) {
      // This might not be cross platform compatible ....
      mediaQuery += " and (-webkit-min-device-pixel-ratio: 2)";
    }

    if (matchMedia(mediaQuery).matches) {
      element.style.backgroundImage = "url('" + image + "')";
    }
  }

  responsiveImageURL(elementID, setResponsiveBackgroundImage);
};

// Adding the class `img--loaded` for images after they are all fully loaded
// - 'containerID' can be like '.hero' or '.articles .article'
var imagesLoading = function(containerID) {
  var containers = document.querySelectorAll(containerID);

  for (var i = 0; i < containers.length; i++) {
    imageLoading(containers[i]);
  }
}

// Adding the class `img-loaded` for images inside a single container
// - uses the imagesLoaded external library
var imageLoading = function(container) {
  var images = container.querySelectorAll('.img');
  var figures = container.querySelectorAll('.figure');

  imagesLoaded(container, function(instance) {
    for (var i = 0; i < images.length; i++) {
      figures[i].classList.add('figure--loaded');
      images[i].classList.add('img--loaded');
    }
  });
}

// On mouse over stop the rotation
var cubeMouseOver = function(containerID) {
  var container = document.querySelector(containerID);

  container.addEventListener("mouseover", function() {
    clearInterval(repeat);
  });

  container.addEventListener("mouseout", function() {
    repeat = setInterval(
      function(){
        cubeRotate('.cube3d');
      },
      2000
    );
  });
}


// Rotate randomly the cube
var cubeRotate = function(containerID) {
  var container = document.querySelector(containerID);
  var xAngle = 0, yAngle = 0;

  var random = Math.floor(Math.random() * 4000);
  var direction = random % 4;

  switch(direction) {
    case 0: // left
      yAngle -= 90;
      break;
    case 1: // up
      xAngle += 90;
      break;
    case 2: // right
      yAngle += 90;
      break;
    case 3: // down
      xAngle -= 90;
      break;
  };

  transform(container, "rotateX(" + xAngle + "deg) rotateY(" + yAngle + "deg)");

  // Cross browser CSS transform
  function transform(container, style) {
    container.style.webkitTransform = style;

    container.style.MozTransform =
    container.style.msTransform =
    container.style.OTransform =
    container.style.transform = style;
  }
}


// Infinite rotate the cube
var repeat = setInterval(
  function(){
    cubeRotate('.cube3d');
  },
  2000
);

// Handle mouse over
cubeMouseOver('.cube__wrap');

var splitName = function(containerID) {
  var container = document.querySelector(containerID);
  var textContainer = container.querySelector('.monogram__name');
  var text = textContainer.innerHTML;

  var charsPerRow = matrixSize(text.length);
  var chars = text.split("");

  for (var i = 0; i < text.length; i++) {
    if ((i % charsPerRow) == 0) {
      createRow(i, Math.min(i + charsPerRow, text.length), chars, container, charsPerRow);
    }
  }
};


// Create a row in the matrix
function createRow(i, max, chars, container, charsPerRow) {
  var row = document.createElement('div');
  row.className = 'monogram__row';
  row.classList.add('monogram__row--cols' + charsPerRow);

  for (var j = i; j < max; j++) {
    var char = createChar(chars[j]);
    row.appendChild(char);
  }

  container.appendChild(row);
}


// Create a character cell in a row
function createChar(character) {
  var char = document.createElement('div');
  char.className = 'character';

  if (character == " ") {
    char.classList.add('character__space');
    char.innerHTML = 'x';
  } else {
    char.innerHTML = character;
  }

  return char;
}



// Calculate matrix size for a text
// - returns the X dimension of the matrix
function matrixSize(length) {
  switch (true) {
    case (length < 4):
      return 2;
      break;
    case (length < 9):
      return 3;
      break;
    case (length < 16):
      return 4;
      break;
    default:
      return 5;
  }
}


splitName('.monogram');
